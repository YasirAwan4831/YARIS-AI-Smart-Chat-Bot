import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Menu } from 'lucide-react';

import Sidebar from './components/Sidebar';
import MessageBubble from './components/MessageBubble';
import InputArea from './components/InputArea';
import TypingIndicator from './components/TypingIndicator';
import AuthPage from './components/AuthPage';
import Footer from "./components/Footer";   // <-- Footer import added

import { Conversation, Message, Role, User } from './types';
import { generateChatResponseStream, generateConversationTitle } from './services/geminiService';

// Helper to generate ID
const generateId = () =>
  crypto.randomUUID
    ? crypto.randomUUID()
    : Math.random().toString(36).substring(2, 15);

const App: React.FC = () => {
  // --- State ---
  const [user, setUser] = useState<User | null>(null);
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [activeConversationId, setActiveConversationId] = useState<string | null>(null);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [authLoading, setAuthLoading] = useState(true);

  // Refs for scrolling
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatContainerRef = useRef<HTMLDivElement>(null);

  // --- Effects ---

  // Check for auth session on mount
  useEffect(() => {
    const savedUser = localStorage.getItem('gemini_user_session');
    if (savedUser) {
      try {
        setUser(JSON.parse(savedUser));
      } catch (e) {
        localStorage.removeItem('gemini_user_session');
      }
    }
    setAuthLoading(false);
  }, []);

  // Load conversations from LocalStorage when user is present
  useEffect(() => {
    if (!user) return;

    const savedKey = `gemini_chat_history_${user.id}`;
    const saved = localStorage.getItem(savedKey);
    if (saved) {
      try {
        const parsed = JSON.parse(saved);
        setConversations(parsed);
        if (parsed.length > 0) {
          setActiveConversationId(parsed[0].id);
        } else {
          createNewChat();
        }
      } catch (e) {
        console.error("Failed to load history", e);
        createNewChat();
      }
    } else {
      createNewChat();
    }
  }, [user]);

  // Save history to LocalStorage
  useEffect(() => {
    if (!user) return;
    const savedKey = `gemini_chat_history_${user.id}`;
    localStorage.setItem(savedKey, JSON.stringify(conversations));
  }, [conversations, user]);

  // Scroll to bottom when messages change
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  useEffect(() => {
    scrollToBottom();
  }, [activeConversationId, conversations]);

  // --- Handlers ---

  const handleLogin = (loggedInUser: User) => {
    setUser(loggedInUser);
    localStorage.setItem('gemini_user_session', JSON.stringify(loggedInUser));
  };

  const handleLogout = () => {
    setUser(null);
    setConversations([]);
    setActiveConversationId(null);
    localStorage.removeItem('gemini_user_session');
  };

  const getActiveConversation = useCallback(() => {
    return conversations.find((c) => c.id === activeConversationId);
  }, [conversations, activeConversationId]);

  const createNewChat = () => {
    const newChat: Conversation = {
      id: generateId(),
      title: 'New Conversation',
      messages: [],
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    setConversations((prev) => [newChat, ...prev]);
    setActiveConversationId(newChat.id);
    setIsSidebarOpen(false);
  };

  const deleteChat = (id: string, e: React.MouseEvent) => {
    e.stopPropagation();
    const newConversations = conversations.filter((c) => c.id !== id);
    setConversations(newConversations);

    if (activeConversationId === id) {
      if (newConversations.length > 0) {
        setActiveConversationId(newConversations[0].id);
      } else {
        setActiveConversationId(null);
        createNewChat();
      }
    }
  };

  const handleSendMessage = async (text: string) => {
    if (!activeConversationId) return;

    const userMessage: Message = {
      id: generateId(),
      role: Role.USER,
      text,
      timestamp: Date.now(),
    };

    setConversations((prev) =>
      prev.map((c) =>
        c.id === activeConversationId
          ? {
              ...c,
              messages: [...c.messages, userMessage],
              updatedAt: Date.now(),
            }
          : c
      )
    );

    setIsTyping(true);

    const responseId = generateId();
    let currentResponseText = '';

    // Add placeholder message
    setConversations((prev) =>
      prev.map((c) =>
        c.id === activeConversationId
          ? {
              ...c,
              messages: [
                ...c.messages,
                {
                  id: responseId,
                  role: Role.MODEL,
                  text: '',
                  timestamp: Date.now(),
                },
              ],
            }
          : c
      )
    );

    try {
      const currentConv = conversations.find((c) => c.id === activeConversationId);
      const history = currentConv ? [...currentConv.messages, userMessage] : [userMessage];

      await generateChatResponseStream(history, text, (chunk) => {
        currentResponseText += chunk;

        setConversations((prev) =>
          prev.map((c) =>
            c.id === activeConversationId
              ? {
                  ...c,
                  messages: c.messages.map((msg) =>
                    msg.id === responseId ? { ...msg, text: currentResponseText } : msg
                  ),
                }
              : c
          )
        );
      });

      const activeConv = getActiveConversation();
      if (activeConv && activeConv.messages.length <= 2) {
        generateConversationTitle(text).then((title) => {
          setConversations((prev) =>
            prev.map((c) =>
              c.id === activeConversationId ? { ...c, title } : c
            )
          );
        });
      }
    } catch (error) {
      setConversations((prev) =>
        prev.map((c) =>
          c.id === activeConversationId
            ? {
                ...c,
                messages: c.messages.map((msg) =>
                  msg.id === responseId
                    ? {
                        ...msg,
                        text: 'I encountered an error connecting to the service. Please try again.',
                        isError: true,
                      }
                    : msg
                ),
              }
            : c
        )
      );
    } finally {
      setIsTyping(false);
    }
  };

  // --- Render Loading ---
  if (authLoading) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-background">
        <div className="w-10 h-10 border-4 border-primary border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  // --- Render Login Screen with Footer ---
  if (!user) {
    return (
      <div className="flex flex-col min-h-screen">
        <div className="flex-1">
          <AuthPage onLogin={handleLogin} />
        </div>
        <Footer /> {/* <-- Footer added for login screen */}
      </div>
    );
  }

  // --- Render Chat App ---
  const activeConversation = getActiveConversation();

  return (
    <div className="flex h-screen bg-background font-sans">
      {/* Sidebar */}
      <Sidebar
        conversations={conversations}
        activeId={activeConversationId}
        isOpen={isSidebarOpen}
        user={user}
        onSelectConversation={setActiveConversationId}
        onNewChat={createNewChat}
        onDeleteChat={deleteChat}
        onCloseMobile={() => setIsSidebarOpen(false)}
        onLogout={handleLogout}
      />

      {/* Main Chat Area */}
      <main className="flex-1 flex flex-col h-full relative min-w-0">

        {/* Top Navigation Bar */}
        <header className="h-14 border-b border-slate-700/50 flex items-center px-4 justify-between md:justify-center bg-surface/50 backdrop-blur-md sticky top-0 z-10">
          <button
            onClick={() => setIsSidebarOpen(true)}
            className="md:hidden p-2 text-slate-400 hover:text-white"
          >
            <Menu size={24} />
          </button>

          <div className="font-medium text-slate-200 truncate max-w-[200px] md:max-w-md">
            {activeConversation?.title || 'Gemini Smart Chat'}
          </div>

          <div className="w-8 md:hidden" />
        </header>

        {/* Chat Messages */}
        <div
          ref={chatContainerRef}
          className="flex-1 overflow-y-auto custom-scrollbar p-4 md:p-6"
        >
          <div className="max-w-3xl mx-auto min-h-full flex flex-col">
            {!activeConversation ||
              activeConversation.messages.length === 0 ? (
              <div className="flex-1 flex flex-col items-center justify-center text-center opacity-50 select-none mt-20 md:mt-0">
                <div className="w-20 h-20 bg-slate-800 rounded-2xl flex items-center justify-center mb-6 rotate-3">
                  <div className="w-12 h-12 bg-gradient-to-tr from-primary to-accent rounded-xl animate-pulse-slow" />
                </div>
                <h2 className="text-2xl font-bold text-slate-200 mb-2">
                  How can I help you today?
                </h2>
                <p className="text-slate-400 max-w-xs">
                  I can help you write code, analyze data, or just have a chat.
                </p>
              </div>
            ) : null}

            {activeConversation?.messages.map((msg) => (
              <MessageBubble key={msg.id} message={msg} />
            ))}

            {isTyping && (
              <div className="mb-6 animate-in fade-in slide-in-from-bottom-2 duration-300">
                <div className="flex gap-3">
                  <div className="flex-shrink-0 h-8 w-8 rounded-full bg-accent text-white flex items-center justify-center">
                    <Menu size={18} className="hidden" />
                    <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin" />
                  </div>
                  <TypingIndicator />
                </div>
              </div>
            )}

            <div ref={messagesEndRef} className="h-4" />
          </div>
        </div>

        {/* Input Box */}
        <InputArea
          onSendMessage={handleSendMessage}
          disabled={isTyping || !activeConversationId}
        />

        {/* Footer */}
        <Footer />  {/* Footer in main chat area */}
      </main>
    </div>
  );
};

export default App;
